### Questions

1. What frameworks have you used?
2. What is Flask, and how does it differ from other frameworks?
3. What are the steps to set up a basic Flask application?
4. As a developer, can you explain the basic process of building an application in Flask?
5. Explain the `__init__.py` file in a directory.
6. What are Flask Blueprints, and when would you use them? How do they help in routing?
7. How does Flask handle HTTP requests and responses?
8. What are Flask templates, and how are they used?
9. How do you handle user authentication and authorization?
10. What are Flask-WTF forms?
11. How do you deploy a Flask application to a production server? Do you configure any reverse proxy?
12. Can you explain the concept of Django migrations?
13. Explain Django middleware and give an example of its usage.
14. Have you used Django admin features?
15. Do you know what components and directives are in Angular, and how does routing work in Angular?
16. Can you explain how decorators work in Python?
17. What are different ways to handle errors in Python?

### Answers

1. **Frameworks Used:** I have used Flask, Django, and Angular for various projects.
2. **Flask:** Flask is a micro-framework for Python based on Werkzeug and Jinja2. It's lightweight and flexible, making it different from more full-featured frameworks like Django, which include more built-in functionalities.
3. **Setting Up Flask:**
   - Install Flask: `pip install Flask`
   - Create a file `app.py`:
     ```python
     from flask import Flask
     app = Flask(__name__)

     @app.route('/')
     def hello_world():
         return 'Hello, World!'

     if __name__ == '__main__':
         app.run()
     ```
   - Run the application: `python app.py`
4. **Building an Application in Flask:** Start with setting up a virtual environment, add Flask and its dependencies, define your app's routes, models, views, and templates, and then test locally before deploying.
5. **`__init__.py`:** This file makes Python treat directories containing it as packages. It can also execute initialization code for a package.
6. **Flask Blueprints:** Blueprints are used for making larger applications in Flask by providing separation of concerns and reusability of components. They are particularly useful for defining views, templates, and static files in a modular way.
7. **Handling HTTP Requests and Responses in Flask:** Flask handles requests by mapping URLs to Python functions, and responses are generated by returning data from these functions, typically using templates.
8. **Flask Templates:** These are Jinja2 templates that Flask uses to render dynamic content. They separate the presentation layer from business logic and are used with the `render_template()` function.
9. **User Authentication and Authorization:** Typically handled using extensions like Flask-Login for authentication and Flask-Principal for authorization, managing sessions, user loading, and rights management.
10. **Flask-WTF Forms:** These are forms handled by the Flask-WTF extension which integrates Flask forms with the WTForms library, providing CSRF protection and validation.
11. **Deploying Flask:** Typically involves setting up a WSGI server like Gunicorn, configuring a reverse proxy like Nginx, and ensuring environment variables and dependencies are properly managed.
12. **Django Migrations:** These are Django's way of propagating changes you make to your models (adding a field, deleting a model, etc.) into your database schema.
13. **Django Middleware:** Middleware is a framework of hooks into Django's request/response processing. It's a lightweight, low-level plugin system for globally altering Djangoâ€™s input or output.
14. **Django Admin Features:** It's a powerful automatic interface for Django models that I've used to quickly build interfaces for site administrators.
15. **Angular Components and Directives:** Components are directives with a template. They manage a view. Angular routing navigates between different components at different URLs.
16. **Python Decorators:** Decorators are a design pattern in Python that allow a user to add new functionality to an existing object without modifying its structure. They are represented by the `@` symbol.
17. **Error Handling in Python:** Typically involves using `try-except` blocks, logging, and using custom exceptions to manage expected and unexpected errors efficiently.

